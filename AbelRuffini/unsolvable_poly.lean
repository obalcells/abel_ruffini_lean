import Mathlib.Analysis.Calculus.LocalExtr.Polynomial
import Mathlib.FieldTheory.AbelRuffini
import Mathlib.RingTheory.RootsOfUnity.Minpoly
import Mathlib.RingTheory.EisensteinCriterion
import Mathlib.Algebra.MonoidAlgebra.Basic
import Mathlib.Algebra.Associated
import Mathlib.GroupTheory.Solvable
import Mathlib.FieldTheory.PolynomialGaloisGroup

-- set_option profiler true
-- set_option synthInstance.maxHeartbeats 140000 -- default is 20000; five times that not enough here
-- set_option trace.Meta.synthInstance true

open Function Polynomial Polynomial.Gal Ideal
open scoped Polynomial
open AddMonoidAlgebra Subgroup

attribute [local instance] splits_ℚ_ℂ

variable (R : Type*) [CommRing R] [Nontrivial R] (a b : ℕ)

noncomputable def Φ : R[X] := X ^ 5 - C (4 : R) * X + C (2 : R)

variable {R}
variable (n : ℕ+)

theorem map_Phi
  {S : Type*}
  [CommRing S]
  (f : R →+* S)
  : (Φ R).map f = Φ S := by
  simp [Φ]

theorem coeff_zero_Phi
  : (Φ R).coeff 0 = 2 := by
  rw [Φ]
  simp

theorem coeff_five_Phi
  : (Φ R).coeff 5 = 1 := by
  rw [Φ]
  simp
  rw [← pow_one X]
  rw [coeff_X_pow]
  simp


theorem degree_Phi_eq_5
  : (Φ R).degree = ((5 : ℕ) : WithBot ℕ) := by
  suffices degree (X ^ 5 - C (4 : R) * X) = ((5 : ℕ) : WithBot ℕ) by
    rwa [Φ, degree_add_eq_left_of_degree_lt]
    convert (degree_C_le).trans_lt (WithBot.coe_lt_coe.mpr (show 0 < 5 by norm_num))
  rw [degree_sub_eq_left_of_degree_lt]
  rw [degree_X_pow]
  apply (degree_C_mul_X_le 4).trans_lt
  rw [degree_X_pow]
  norm_num

theorem nat_degree_Phi_eq_5
  [Nontrivial R]
  : natDegree (Φ R) = 5 := by
  apply natDegree_eq_of_degree_eq_some degree_Phi_eq_5


theorem leading_coeff_Phi_eq_one
  : (Φ R).leadingCoeff = 1 := by
  rw [Polynomial.leadingCoeff]
  rw [nat_degree_Phi_eq_5]
  apply coeff_five_Phi

theorem is_monic_Phi
  : (Φ R).Monic := by
  unfold Monic
  rw [Polynomial.leadingCoeff]
  apply leading_coeff_Phi_eq_one

theorem is_primitive_Phi
  : IsPrimitive (Φ ℤ) := by
  /- We just need to use the fact that it's monic to prove that it's primitive -/
  apply Monic.isPrimitive is_monic_Phi


theorem is_irreducible_Phi
  (p : ℕ)
  (hp : p.Prime)
  (hp_div_2 : p ∣ 2)
  (hp_div_4 : p ∣ 4)
  (hp_ne_div_sq : ¬p ^ 2 ∣ 2)
  : Irreducible (Φ ℚ) := by

  /- We first want to use Gauss' Lemma but for that we have to rewrite (Φ ℚ) as a polynomial in ℤ -/
  /- (Int.castRingHom ℚ) is a (homomorphism) map from ℤ → ℚ -/
  /- With this rw we're moving the polynomial to ℤ -/
  /- The polynomial we get is equivalent because the map we move it with is a ring homomorphism -/
  rw [← map_Phi (Int.castRingHom ℚ)]

  /- At this step we're using Gauss' Lemma -/
  /- A new subgoal will be created because we have to show it's a primitive polynomial too -/
  /- We'll solve that goal later, now we'll just prove that the polynomial (in ℤ) is irreducible -/
  rw [← IsPrimitive.Int.irreducible_iff_irreducible_map_cast]

  /- Now it's time to apply Eisenstein's Lemma to show irreducibility -/
  apply irreducible_of_eisenstein_criterion
  · /- The eisenstein theorem expects us to provide a proof for a prime ideal -/
    /- We want to use the ideal generated by the prime p, so it will be P = pℤ  -/
    /- We'll convert the goal from showing isPrime ?P to Prime p -/
    /- This is equivalent because the ideal generated by p is prime if and only if p is prime -/
    rw [span_singleton_prime (Int.coe_nat_ne_zero.mpr hp.ne_zero)]

    /- We want the prime to be casted back to ℕ (it's currently in ℤ) -/
    rw [Int.prime_iff_natAbs_prime]
    exact hp

  · /- We want to show that the leading coefficient of Φ ℤ is not spanned by the prime p -/
    /- We'll use the fact that the leading coefficient is 1, so it can't be divisible by the prime p -/
    rw [leading_coeff_Phi_eq_one]
    /- The following lemma says that x ∈ span { p } is equivalent to p | x -/
    rw [mem_span_singleton]
    /- We now want to show that p doesn't divide 1 -/
    /- Nat.dvd_one says that n ∣ 1 ↔ n = 1 -/
    /- We want to use the fact that p ≠ 1 to show that ¬(p | 1) -/
    /- mt inverts the equivalence such that for a ↔ b and ¬a implies ¬b -/
    exact mod_cast mt Nat.dvd_one.mp hp.ne_one

  · /- Now we have to prove that the coefficients aren't divisible by p -/
    intro n
    rw [degree_Phi_eq_5]
    intro hn
    sorry /- ): -/
  · rw [degree_Phi_eq_5]
    /- Now we just need to prove 0 < 5. We'll use apply? -/
    exact sign_eq_one_iff.mp rfl

  · rw [coeff_zero_Phi]
    /- TODO -/
    sorry

  · exact is_primitive_Phi

  /- Now we just have to prove that Φ is primitive -/
  exact is_primitive_Phi


theorem real_roots_Phi_ge : 2 ≤ Fintype.card ((Φ ℚ).rootSet ℝ) := by
  sorry /- see wolfram alpha (: -/

theorem real_roots_Phi_le : Fintype.card ((Φ ℚ).rootSet ℝ) ≤ 3 := by
  sorry

theorem complex_roots_Phi (h : (Φ ℚ).Separable) : Fintype.card ((Φ ℚ).rootSet ℂ) = 5 :=
  (card_rootSet_eq_natDegree h (IsAlgClosed.splits_codomain _)).trans (nat_degree_Phi_eq_5)

instance fact_prime_five : Nat.Prime 5 := sorry

theorem galois_group_Phi (h_irred : Irreducible (Φ ℚ)) :
    Bijective (galActionHom (Φ ℚ) ℂ) := by
  /- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/
  apply galActionHom_bijective_of_prime_degree' h_irred
  · /- First we have to prove that the polynomial has prime degree-/
    rw [nat_degree_Phi_eq_5]
    exact fact_prime_five
  · /- Now we want to show that cardinality (rootSet (Φ ℚ) ℝ) + 1 ≤ cardinality (rootSet (Φ ℚ) ℂ) -/
    /- We can use the previous bounds we found -/
    /- Also, we fix the +1 inequality using succ -/
    rw [complex_roots_Phi h_irred.separable, Nat.succ_le_succ_iff]
    /- Now we just replace the bound on the real roots now -/
    exact real_roots_Phi_le.trans (Nat.le_succ 3)
  · /- Now we prove the bound -/
    /- Fintype.card ↑(rootSet (Φ ℚ) ℂ) ≤ Fintype.card ↑(rootSet (Φ ℚ) ℝ) + 3 -/
    simp_rw [complex_roots_Phi h_irred.separable, Nat.succ_le_succ_iff]
    exact real_roots_Phi_ge

theorem not_solvable_by_rad
  (p : ℕ)
  (x : ℂ)
  (hx : aeval x (Φ ℚ) = 0)
  (hp : p.Prime)
  (hp_div_2 : p ∣ 2)
  (hp_div_4 : p ∣ 4)
  (hp_ne_div_sq : ¬p ^ 2 ∣ 2)
  : ¬IsSolvableByRad ℚ x := by
  /- first we check that it's irreducible -/
  have h_irred := is_irreducible_Phi p hp hp_div_2 hp_div_4 hp_ne_div_sq

  /- We apply Abel Ruffini's theorem to -/
  /- go from ¬SolvableByRad to ¬GaloisGroupIsSolvable -/
  apply mt (solvableByRad.isSolvable' h_irred hx)

  /- We introduce this so that the goal becomes to prove False -/
  intro h

  /- We use the proof that Sₙ isn't solvable for n ≥ 5 -/
  refine' Equiv.Perm.not_solvable _ (le_of_eq _) (solvable_of_surjective (galois_group_Phi h_irred).2)

  rw_mod_cast [Cardinal.mk_fintype, complex_roots_Phi h_irred.separable]
